<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Yen-Chun Huang</title>
  <link rel="icon" href="./assets/favicon.ico" type="image/x-icon">
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');

    body {
      font-family: 'Inter', sans-serif;
      cursor: none;
      background-color: #0a0a0a;
    }

    .node.visited {
      background-color: #facc15 !important;
      border-color: #facc15 !important;
      color: #111827 !important;
      transform: scale(1.05);
    }

    #last-node {
      display: flex;
      flex-direction: column;
      text-align: center;
      line-height: 1.2;
      padding: 0.5rem;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
    }
  </style>
</head>

<body class="text-white overflow-hidden">

  <canvas id="visual-canvas" class="fixed top-0 left-0 w-full h-full z-0"></canvas>

  <div id="game-container" class="relative w-full h-screen z-10">
    <div class="node" data-keyword="Evolve">Evolve</div>
    <div class="node" data-keyword="Prototype">Prototype</div>
    <div class="node" data-keyword="Code">Code</div>
    <div class="node" data-keyword="Design">Design</div>

    <div id="last-node"
      class="node absolute bg-transparent border-2 border-yellow-400 items-center justify-center h-16 w-40 text-sm font-bold select-none transition-all duration-300"
      data-keyword="Yen-Chun Huang">
      <span>Yen-Chun</span>
      <span>Huang</span>
    </div>
  </div>

  <div id="success-screen"
    class="hidden fixed inset-0 z-20 bg-black/80 flex flex-col items-center justify-center text-center p-8 backdrop-blur-sm">
    <h1 class="text-5xl font-bold text-yellow-400 mb-4">Network Activated!</h1>
    <p class="text-xl text-gray-300 mb-8">You've explored all the connections.</p>
    <button id="next-page-button"
      class="bg-yellow-500 text-gray-900 font-bold py-3 px-8 text-lg hover:bg-yellow-400 transition-colors duration-300 focus:outline-none focus:ring-2 focus:ring-yellow-300">
      Proceed to Next Page
    </button>
  </div>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const canvas = document.getElementById('visual-canvas');
      const ctx = canvas.getContext('2d');
      const initialNodes = Array.from(document.querySelectorAll('.node:not(#last-node)'));
      const lastNode = document.getElementById('last-node');
      const allNodes = [...initialNodes, lastNode];
      const successScreen = document.getElementById('success-screen');

      let particles = [];
      let mouse = { x: null, y: null };
      const visitedNodes = new Set();
      let energyPulses = [];
      let nodeCycle = [];

      const getCenter = (element) => {
        if (!element || element.style.display === 'none') return null;
        const rect = element.getBoundingClientRect();
        return { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };
      };

      const getEdgePoint = (fromElement, toElement) => {
        const fromRect = fromElement.getBoundingClientRect();
        const toRect = toElement.getBoundingClientRect();

        const fromCenter = { x: fromRect.left + fromRect.width / 2, y: fromRect.top + fromRect.height / 2 };
        const toCenter = { x: toRect.left + toRect.width / 2, y: toRect.top + toRect.height / 2 };

        // Calculate angle from source to target
        const angle = Math.atan2(toCenter.y - fromCenter.y, toCenter.x - fromCenter.x);

        // Calculate intersection point with FROM element's border (rectangular)
        const halfWidthFrom = fromRect.width / 2;
        const halfHeightFrom = fromRect.height / 2;
        const tanAngle = Math.tan(angle);
        let fromEdgeX, fromEdgeY;

        if (Math.abs(tanAngle) <= halfHeightFrom / halfWidthFrom) {
          // Left or right edge
          if (toCenter.x > fromCenter.x) {
            fromEdgeX = fromCenter.x + halfWidthFrom;
            fromEdgeY = fromCenter.y + (fromEdgeX - fromCenter.x) * tanAngle;
          } else {
            fromEdgeX = fromCenter.x - halfWidthFrom;
            fromEdgeY = fromCenter.y + (fromEdgeX - fromCenter.x) * tanAngle;
          }
        } else {
          // Top or bottom edge
          if (toCenter.y > fromCenter.y) {
            fromEdgeY = fromCenter.y + halfHeightFrom;
            fromEdgeX = fromCenter.x + (fromEdgeY - fromCenter.y) / tanAngle;
          } else {
            fromEdgeY = fromCenter.y - halfHeightFrom;
            fromEdgeX = fromCenter.x + (fromEdgeY - fromCenter.y) / tanAngle;
          }
        }

        // Calculate intersection point with TO element's border (rectangular)
        const halfWidthTo = toRect.width / 2;
        const halfHeightTo = toRect.height / 2;
        let toEdgeX, toEdgeY;

        if (Math.abs(tanAngle) <= halfHeightTo / halfWidthTo) {
          // Left or right edge
          if (toCenter.x > fromCenter.x) {
            toEdgeX = toCenter.x - halfWidthTo;
            toEdgeY = toCenter.y - (toCenter.x - toEdgeX) * tanAngle;
          } else {
            toEdgeX = toCenter.x + halfWidthTo;
            toEdgeY = toCenter.y - (toCenter.x - toEdgeX) * tanAngle;
          }
        } else {
          // Top or bottom edge
          if (toCenter.y > fromCenter.y) {
            toEdgeY = toCenter.y - halfHeightTo;
            toEdgeX = toCenter.x - (toCenter.y - toEdgeY) / tanAngle;
          } else {
            toEdgeY = toCenter.y + halfHeightTo;
            toEdgeX = toCenter.x - (toCenter.y - toEdgeY) / tanAngle;
          }
        }

        return { from: { x: fromEdgeX, y: fromEdgeY }, to: { x: toEdgeX, y: toEdgeY } };
      };

      const setupCanvas = () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      };

      const positionInitialNodes = () => {
        const W = window.innerWidth;
        const H = window.innerHeight;
        const nodeWidth = 160;
        const nodeHeight = 64;

        // Define 4 large placement zones (quadrants)
        const safeMargin = {
          x: Math.max(60, W * 0.1),
          y: Math.max(60, H * 0.1)
        };
        const halfW = W / 2;
        const halfH = H / 2;

        const quadrants = [
          { x: safeMargin.x, y: safeMargin.y, w: halfW - safeMargin.x * 1.5, h: halfH - safeMargin.y * 1.5 },
          { x: halfW + safeMargin.x * 0.5, y: safeMargin.y, w: halfW - safeMargin.x * 1.5, h: halfH - safeMargin.y * 1.5 },
          { x: W - safeMargin.x - (halfW - safeMargin.x * 1.5), y: H - safeMargin.y - (halfH - safeMargin.y * 1.5), w: halfW - safeMargin.x * 1.5, h: halfH - safeMargin.y * 1.5 },
          { x: safeMargin.x, y: H - safeMargin.y - (halfH - safeMargin.y * 1.5), w: halfW - safeMargin.x * 1.5, h: halfH - safeMargin.y * 1.5 }
        ];

        nodeCycle = [...initialNodes].sort(() => 0.5 - Math.random());

        nodeCycle.forEach((node, index) => {
          const q = quadrants[index];
          const x = q.x + Math.random() * (q.w - nodeWidth);
          const y = q.y + Math.random() * (q.h - nodeHeight);
          node.style.left = `${x}px`;
          node.style.top = `${y}px`;
          node.className = 'node absolute bg-transparent border-2 border-yellow-400 flex items-center justify-center h-16 w-40 text-sm font-bold select-none transition-all duration-300';
        });
      };

      const createPulsesFromVisitedNodes = () => {
        energyPulses = [];

        // For each visited node, create pulses to unvisited neighbors
        visitedNodes.forEach(visitedNode => {
          const startPoint = getCenter(visitedNode);
          if (!startPoint) return;

          if (initialNodes.includes(visitedNode)) {
            const currentIndex = nodeCycle.indexOf(visitedNode);
            const nextNode = nodeCycle[(currentIndex + 1) % nodeCycle.length];
            const prevNode = nodeCycle[(currentIndex - 1 + nodeCycle.length) % nodeCycle.length];

            // Pulse to neighbors in the cycle if they aren't visited
            if (!visitedNodes.has(nextNode)) {
              energyPulses.push(new EnergyPulse(visitedNode, nextNode));
            }
            if (!visitedNodes.has(prevNode)) {
              energyPulses.push(new EnergyPulse(visitedNode, prevNode));
            }

            // Pulse to last node if all initial nodes are visited and last node isn't
            if (visitedNodes.size === initialNodes.length && lastNode.style.display !== 'none' && !visitedNodes.has(lastNode)) {
              energyPulses.push(new EnergyPulse(visitedNode, lastNode));
            }
          }
          else if (visitedNode === lastNode) {
            initialNodes.forEach(outerNode => {
              if (!visitedNodes.has(outerNode)) {
                energyPulses.push(new EnergyPulse(visitedNode, outerNode));
              }
            });
          }
        });
      };

      const handleNodeEnter = (event) => {
        const node = event.target;

        if (!visitedNodes.has(node)) {
          node.classList.add('visited');
          visitedNodes.add(node);

          // Create firework burst when the last node (name) is visited
          if (node === lastNode) {
            const center = getCenter(lastNode);
            if (center) {
              createFireworkBurst(center.x, center.y);
            }
          }
        }

        if (visitedNodes.size === initialNodes.length && lastNode.style.display === 'none') {
          lastNode.style.display = 'flex';
        }

        // Always recreate pulses after any node interaction
        createPulsesFromVisitedNodes();

        if (visitedNodes.size === allNodes.length) {
          energyPulses = [];
          setTimeout(() => {
            window.location.href = 'portfolio.html';
          }, 1000);
        }
      };

      const handleMouseMove = (e) => {
        mouse.x = e.clientX; mouse.y = e.clientY;
        for (let i = 0; i < 5; i++) particles.push(new Particle(mouse.x, mouse.y));
      };

      class Particle {
        constructor(x, y) {
          this.x = x; this.y = y; this.size = Math.random() * 3 + 1;
          this.speedX = Math.random() * 6 - 3; this.speedY = Math.random() * 6 - 3;
          this.life = 1; const baseHue = 45; const hueSpread = 40;
          const hue = (baseHue + (Math.random() * hueSpread) - (hueSpread / 2));
          this.color = `hsl(${hue}, 100%, ${60 + Math.random() * 25}%)`;
        }
        update() {
          this.x += this.speedX; this.y += this.speedY;
          if (this.size > 0.1) this.size -= 0.05; this.life -= 0.025;
        }
        draw() {
          ctx.globalAlpha = Math.max(0, this.life); ctx.fillStyle = this.color;
          ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill();
        }
      }

      class FireworkParticle {
        constructor(x, y, hue) {
          this.x = x;
          this.y = y;
          const angle = Math.random() * Math.PI * 2;
          const speed = Math.random() * 8 + 4;
          this.speedX = Math.cos(angle) * speed;
          this.speedY = Math.sin(angle) * speed;
          this.size = Math.random() * 4 + 2;
          this.life = 1;
          this.gravity = 0.15;
          this.hue = hue;
          this.color = `hsl(${hue}, 100%, ${60 + Math.random() * 20}%)`;
        }
        update() {
          this.speedY += this.gravity;
          this.x += this.speedX;
          this.y += this.speedY;
          this.life -= 0.015;
          if (this.size > 0.1) this.size -= 0.08;
        }
        draw() {
          ctx.globalAlpha = Math.max(0, this.life);
          ctx.fillStyle = this.color;
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
          ctx.fill();

          // Add glow
          ctx.shadowColor = this.color;
          ctx.shadowBlur = 15;
          ctx.fill();
          ctx.shadowBlur = 0;
        }
      }

      let fireworkParticles = [];

      const createFireworkBurst = (x, y) => {
        const hues = [45, 30, 60, 50, 40]; // Yellow/gold variations
        for (let i = 0; i < 100; i++) {
          const hue = hues[Math.floor(Math.random() * hues.length)];
          fireworkParticles.push(new FireworkParticle(x, y, hue));
        }
      };

      class EnergyPulse {
        constructor(fromNode, toNode) {
          this.fromNode = fromNode;
          this.toNode = toNode;
          this.progress = 0;
          this.tailLength = 0.15;
        }
        update() {
          this.progress += 0.015;
          if (this.progress > 1 + this.tailLength) this.progress = 0;
        }
        draw() {
          const edgePoints = getEdgePoint(this.fromNode, this.toNode);
          if (!edgePoints) return;

          const start = edgePoints.from;
          const end = edgePoints.to;

          const headProgress = Math.min(this.progress, 1);
          const tailProgress = Math.max(0, this.progress - this.tailLength);
          if (headProgress <= tailProgress) return;

          const headX = start.x + (end.x - start.x) * headProgress;
          const headY = start.y + (end.y - start.y) * headProgress;
          const tailX = start.x + (end.x - start.x) * tailProgress;
          const tailY = start.y + (end.y - start.y) * tailProgress;
          const gradient = ctx.createLinearGradient(tailX, tailY, headX, headY);
          gradient.addColorStop(0, 'rgba(254, 240, 138, 0)');
          gradient.addColorStop(1, '#fef08a');
          ctx.strokeStyle = gradient; ctx.lineWidth = 4; ctx.lineCap = 'round';
          ctx.shadowColor = '#f59e0b'; ctx.shadowBlur = 20;
          ctx.beginPath(); ctx.moveTo(tailX, tailY); ctx.lineTo(headX, headY); ctx.stroke();
          ctx.shadowBlur = 0;
        }
      }

      const animate = () => {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        for (let i = 0; i < nodeCycle.length; i++) {
          const startNode = nodeCycle[i];
          const endNode = nodeCycle[(i + 1) % nodeCycle.length];
          const edgePoints = getEdgePoint(startNode, endNode);
          if (edgePoints) {
            const bothVisited = visitedNodes.has(startNode) && visitedNodes.has(endNode);
            ctx.beginPath();
            ctx.moveTo(edgePoints.from.x, edgePoints.from.y);
            ctx.lineTo(edgePoints.to.x, edgePoints.to.y);
            ctx.lineWidth = bothVisited ? 3 : 2;
            ctx.strokeStyle = bothVisited ? '#facc15' : 'rgba(250, 204, 21, 0.2)';
            if (bothVisited) { ctx.shadowColor = '#facc15'; ctx.shadowBlur = 10; }
            ctx.stroke(); ctx.shadowBlur = 0;
          }
        }

        if (lastNode.style.display !== 'none') {
          initialNodes.forEach(node => {
            const edgePoints = getEdgePoint(node, lastNode);
            if (edgePoints) {
              const bothVisited = visitedNodes.has(node) && visitedNodes.has(lastNode);
              ctx.beginPath();
              ctx.moveTo(edgePoints.from.x, edgePoints.from.y);
              ctx.lineTo(edgePoints.to.x, edgePoints.to.y);
              ctx.lineWidth = bothVisited ? 3 : 2;
              ctx.strokeStyle = bothVisited ? '#facc15' : 'rgba(250, 204, 21, 0.2)';
              if (bothVisited) { ctx.shadowColor = '#facc15'; ctx.shadowBlur = 10; }
              ctx.stroke(); ctx.shadowBlur = 0;
            }
          });
        }

        energyPulses.forEach(pulse => { pulse.update(); pulse.draw(); });

        for (let i = particles.length - 1; i >= 0; i--) {
          particles[i].update(); particles[i].draw();
          if (particles[i].life <= 0) particles.splice(i, 1);
        }

        for (let i = fireworkParticles.length - 1; i >= 0; i--) {
          fireworkParticles[i].update(); fireworkParticles[i].draw();
          if (fireworkParticles[i].life <= 0) fireworkParticles.splice(i, 1);
        }

        ctx.globalAlpha = 1;

        if (mouse.x) {
          ctx.beginPath(); ctx.arc(mouse.x, mouse.y, 8, 0, Math.PI * 2);
          ctx.strokeStyle = '#fde047'; ctx.lineWidth = 2; ctx.stroke();
        }
        requestAnimationFrame(animate);
      };

      // --- Initial Setup ---
      lastNode.style.display = 'none';
      setupCanvas();
      positionInitialNodes();
      animate();

      window.addEventListener('resize', () => {
        setupCanvas();
        positionInitialNodes();
        lastNode.style.display = 'none';
        visitedNodes.clear();
        allNodes.forEach(n => n.classList.remove('visited'));
        energyPulses = [];
      });

      window.addEventListener('mousemove', handleMouseMove);
      allNodes.forEach(node => { node.addEventListener('mouseenter', handleNodeEnter); });
      document.getElementById('next-page-button').addEventListener('click', () => location.reload());
    });
  </script>
</body>

</html>